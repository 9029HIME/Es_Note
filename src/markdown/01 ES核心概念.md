# 前言

​	这里先不记录ES历史（像什么Lucene，Hadoop的关联什么的）以及整个环境的搭建（毕竟都开箱即用了），这份笔记是基于已搭好ElasticSearch（整合IK分词器与自定义分词）与Kibana进行的

# 核心概念

​	开门见山，ES是面向文档的，和关系型数据库如MySQL有明显差异但类似，以下是两者类似的概念。但是在ES里，**所有概念都是基于JSON格式表示**。

|  MySQL   |                  ES                  |
| :------: | :----------------------------------: |
| database |           索引（indices）            |
|  table   | types（然而逐渐被弱化，8.x甚至废除） |
|   rows   |              documents               |
|  column  |                fields                |

## document&fields

​	document是es中数据的最小单元，用来存储一个**最小的、完整的**数据，打个比方，创建一个document用来保存牙膏商品信息

```
{
"product_id": "00001",
"product_name": "牙膏",
"product_desc": "描述...",
"category_id": "分类Id",
"category_name": "分类名称..."
}
```

​	而fields是document中的最小单元，一个document可以包含多个fields，每一个field对应一个数据字段，在product这个docuemnt里，product_id、product_name等都是field。	

## indices

​	一个index包含一堆**结构相似**的document，假设创建了一个名叫product的index专门存放产品数据，那么这个index可以存放多个上面的document。ES在后台将每个**index**划分成多个**分片**，每个分片可以在**集群**中不同节点内迁移。先说一下，一个ES服务器代表着一个集群，一个集群至少有一个**节点**。

![一个ES代表一个集群](https://user-images.githubusercontent.com/48977889/109619511-d16d7880-7b73-11eb-908d-50d80364f363.png)

​	假设我创建一个索引P，P默认会**分成**5个分片P0、P1、P2、P3、P4，每一个分片本质是一个**Lucene索引**，他是一个**倒排索引****，且**每一个分片**会有一个**分片副本**，即R0、R1、R2、R3、R4，也就是说创建一个索引至少会创建出10个其分片（5个主分片，5个副本分片）

![02 分片与副本](https://user-images.githubusercontent.com/48977889/109620617-0deda400-7b75-11eb-8bf5-839dae7b01d8.png)

​	这里假设一个集群有三个节点，创建了索引P，为了让查询请求分布到多台节点上，提升吞吐量和性能，保证节点宕机后的数据还原，ES会这样划分（具体的划分策略ES帮我们做好了，TODO 可以开新坑去了解一下），**注意！！！主分片与对应的副本分片不会划分在同一个节点上！！！即P1和R1不会在同一个节点上。**

​	![03 分片划分](https://user-images.githubusercontent.com/48977889/109623293-f663ea80-7b77-11eb-9bed-10125e599346.jpg)

### 倒排索引 TODO 这里只记录倒排索引的一般解释，具体存储、过程需要开新坑

​	是ES里索引的底层数据结构，也叫反向索引，与正向索引不同的是：**“倒排索引是通过部分value来查询key，再通过key来查询整个value”**，他有点类似MYISAM的索引结构（当然只是类似）

​	假设有文档A与文档B，文档A的内容是："A、B、C、D、E、F、G"，文档2的内容是："D、E、F、G、H、I、J"，此时有以下关系

| 关键字 | 文档A | 文档B |
| ------ | ----- | ----- |
| A      | √     | ×     |
| B      | √     | ×     |
| C      | √     | ×     |
| D      | √     | √     |
| E      | √     | √     |
| F      | √     | √     |
| G      | √     | √     |
| H      | ×     | √     |
| I      | ×     | √     |
| J      | ×     | √     |

​	此时我查询关键字为A、E的数据时，会发现只有文档A符合这两个关键字条件，即文档A的**权重（score）**更高，然后就会从文档A里对关键字A、E进行搜索。

​	**TODO 当然，倒排索引的具体结构，具体存储过程与查询过程，就要以后开新坑了，这里只做大致介绍**



