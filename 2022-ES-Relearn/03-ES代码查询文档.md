# RestClient

## 18-RestClient搜索

RestClient的搜索是基于SearchRequest完成的，通过SearchRequest::Source()返回的SearchSourceBuilder可以构建DSL语句。SearchSourceBuilder的API和DSL的结构都是一一对应的，默认情况下它的API都是构建DSL语句的一级JSON KEY，每一个一级JSON KEY的返回值都能继续构建其在DSL的下级结构，从而达到链式编程构建DSL的效果。以基础的match查询来看：

```java
@Test
public void TestNormalQuery() throws IOException {
    SearchRequest request = new SearchRequest("hotel");
    request.source().
            query(
                    QueryBuilders.matchQuery(
                            "name", "上海旅游"
                    )
            );
    SearchResponse response = restHighLevelClient.search(request, RequestOptions.DEFAULT);
}
```

这样的查询效果以下DSL是一样的

```json
{
	"query":{
		"match":{
			"name":"上海旅游"
		}
	}
}		
```

## 19-RestClient响应

基于知识点18，其实响应结果SearchResponse本质也是对DSL查询响应的JSON的一个封装，对象的层级结构和响应JSON的层级结构也是一样的，以下编写一个公共方法返回查询结果：

```java
public <T> EsResponse<T> analysisResponse(SearchResponse response, Class<T> returnType){
    EsResponse result = new EsResponse();
    SearchHit[] hits = response.getHits().getHits();
    TotalHits totalHits = response.getHits().getTotalHits();
    result.setTotal(totalHits.value);

    List<T> payload = new LinkedList<>();
    for (SearchHit hit : hits) {
        String sourceAsString = hit.getSourceAsString();
        T t = JSONObject.parseObject(sourceAsString, returnType);
        payload.add(t);
    }
    result.setPayload(payload);
    return result;
}
```

## 20-对外封装接口

不要满足于单元测试了，以下结合SpringBoot工程，暴露一个查询接口，要求：通过关键字查询brandAndName这个复合字段。

```java
@RestController
@RequestMapping("/hotel")
public class HotelController {

    @Autowired
    private IHotelService hotelService;

    @GetMapping("/keywordQuery")
    public EsResponse<HotelEsDTO> keywordQuery(@RequestParam(value = "keyword",required = true) String keyword) throws IOException {
        return hotelService.keywordQuery(keyword);
    }
}
```

```java
@Service
public class HotelServiceImpl implements IHotelService {
    @Autowired
    private RestHighLevelClient esClient;


    @Override
    public EsResponse<HotelEsDTO> keywordQuery(String keyword) throws IOException {
        SearchRequest request = new SearchRequest("hotel");
        request.source()
                .query(
                        QueryBuilders.matchQuery(
                                "brandAndName", keyword
                        )
                );
        SearchResponse response = esClient.search(request, RequestOptions.DEFAULT);
        EsResponse<HotelEsDTO> result = EsUtil.analysisResponse(response, HotelEsDTO.class);
        return result;
    }
}
```

测试结果：

![image](https://user-images.githubusercontent.com/48977889/168409577-34391772-da8e-4588-a6af-1046119c6120.png)

## 21-总结

结合18-20这三个知识点，可以看到RestClient的查询只需遵循DSL的结构即可，根据不同的需求可以动态扩充，差别就是API名称不同而已。

# 代码扩展

## 22-多条件查询

然而在实际生产环境中，搜索肯定不止关键字，还有下拉框等附加条件信息，这就涉及到多条件查询了。知识点20写的代码仅支持1个关键字的查询，因此需要作出改造，改造思路如下：

1.新增查询条件：city（精确）、brand（精确）、starName(精确)、price（范围）。

2.POST请求，body采用一个对象来接受，这个对象里包含了参与查询的条件。

3.通过注解+反射的形式，读取对象里的属性值，如果有值，则动态扩展SearchRequest的API。

```java
public class QueryHotelCommand implements CommonEsQuery {
    @Match
    private String brandAndName;
    @Term
    private String city;
    @Term
    private String brand;
    @Term
    private String starName;
    @RangeFrom
    private String priceFrom;
    @RangeTo
    private String priceTo;
}
```

```java
@PostMapping("/multiQuery")
public EsResponse<HotelEsDTO> multiQuery(@RequestBody QueryHotelCommand command) throws IOException, IllegalAccessException {
    return hotelService.multiQuery(command);
}
```

```java
@Override
public EsResponse<HotelEsDTO> multiQuery(QueryHotelCommand command) throws IllegalAccessException, IOException {
    SearchRequest request = dynamicQuery("hotel", command);
    SearchResponse response = esClient.search(request, RequestOptions.DEFAULT);
    EsResponse<HotelEsDTO> result = EsUtil.analysisResponse(response, HotelEsDTO.class);
    return result;
}

public SearchRequest dynamicQuery(String indexName,Object queryParam) throws IllegalAccessException {
    if(! (queryParam instanceof CommonEsQuery) ){
        throw new RuntimeException("error param");
    }
    SearchRequest request = new SearchRequest(indexName);
    BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
    request.source().query(boolQueryBuilder);

    Class<?> aClass = queryParam.getClass();
    Field[] fields = aClass.getDeclaredFields();
    for (Field field : fields) {
        field.setAccessible(true);
        String name = field.getName();
        String value = (String) field.get(queryParam);
        if(StringUtils.isEmpty(value)){
            continue;
        }
        if(field.isAnnotationPresent(Match.class)){
            boolQueryBuilder.must(
                    QueryBuilders.matchQuery(
                            name,value
                    )
            );
        }else if(field.isAnnotationPresent(Term.class)){
            boolQueryBuilder.must(
                    QueryBuilders.termQuery(
                            name,value
                    )
            );
        }else if(field.isAnnotationPresent(RangeFrom.class)){
            boolQueryBuilder.must(
                    QueryBuilders.rangeQuery("price").gte(value)
            );
        }else if(field.isAnnotationPresent(RangeTo.class)){
            boolQueryBuilder.must(
                    QueryBuilders.rangeQuery("price").lte(value)
            );
        }
    }
    return request;
}
```

## 23-新增附近酒店功能

这个功能的潜在意思是：1.按照经纬度查找距离自己最近的酒店，也就是说要根据距离倒叙排序。2.返回的时候要把距离加到响应，显示距离。

1.

```java
public class QueryHotelCommand implements CommonEsQuery {
    @Match
    private String brandAndName;
    @Term
    private String city;
    @Term
    private String brand;
    @Term
    private String starName;
    @RangeFrom
    private String priceFrom;
    @RangeTo
    private String priceTo;
    @Location
    private String location;
}
```

```java
else if(field.isAnnotationPresent(Location.class)){
    String[] split = value.split(",");
    String longitude = split[0];
    String latitude = split[1];
    request.source().sort(
            SortBuilders.geoDistanceSort("location", Double.valueOf(latitude),Double.valueOf(longitude))
                    .order(SortOrder.ASC)
                    .unit(DistanceUnit.KILOMETERS)
    );
}
```

2.在解析响应的时候，把距离也给加上

```java
public class GeoResult {
    private String sortValue;

    public String getSortValue() {
        return sortValue;
    }

    public void setSortValue(String sortValue) {
        this.sortValue = sortValue;
    }
}
```

```java
    @Override
    public EsResponse<HotelEsDTO> multiQuery(QueryHotelCommand command) throws IllegalAccessException, IOException {
        SearchRequest request = dynamicQuery("hotel", command);
        SearchResponse response = esClient.search(request, RequestOptions.DEFAULT);
//        EsResponse<HotelEsDTO> result = EsUtil.analysisResponse(response, HotelEsDTO.class);
        // 03-23：整理好经纬度距离并返回
        EsResponse<HotelEsDTO> result = EsUtil.analysisGeoResponse(response, HotelEsDTO.class);
        return result;
    }
```

```java
public static <T extends GeoResult> EsResponse<T> analysisGeoResponse(SearchResponse response, Class<T> returnType){
    EsResponse result = new EsResponse();
    SearchHit[] hits = response.getHits().getHits();
    TotalHits totalHits = response.getHits().getTotalHits();
    result.setTotal(totalHits.value);

    List<T> payload = new LinkedList<>();
    for (SearchHit hit : hits) {
        String sourceAsString = hit.getSourceAsString();
        T t = JSONObject.parseObject(sourceAsString, returnType);

        Object[] sortValues = hit.getSortValues();
        if(sortValues.length > 0){
            String sortValue = String.valueOf(sortValues[0]);
            t.setSortValue(sortValue);
        }
        payload.add(t);
    }
    result.setPayload(payload);
    return result;
}
```

![image](https://user-images.githubusercontent.com/48977889/168413775-bfe3c870-4c19-4711-935e-6af0e0118347.png)

## 24-新增广告权重功能，花钱越大，权重越高

要明确的是，使用广告权重的时候不能使用自定义排序（如距离排序），这样会有冲突。

首先往索引里新增advertiseAmount字段：

```
PUT hotel/_mapping/
{
  "properties":{
    "advertiseAmount":{
      "type":"double"
    }
  }
}
```

在查询的时候，新增FunctionQueryScore查询：

```java
public SearchRequest dynamicQuery(String indexName, Object queryParam) throws IllegalAccessException {
        if (!(queryParam instanceof CommonEsQuery)) {
            throw new RuntimeException("error param");
        }
        SearchRequest request = new SearchRequest(indexName);
//        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
//        request.source().query(boolQueryBuilder);

        //03-24，要实现广告排序效果
        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();
        FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery(
                // 使用下面for循环动态拼接的复合查询
                boolQueryBuilder,
                new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{
                        new FunctionScoreQueryBuilder.FilterFunctionBuilder(
                                // 定义过滤条件：有advertiseAmount值的才参与重新算分
                                QueryBuilders.existsQuery("advertiseAmount"),
                                // 定义算分函数，直接将advertiseAmount作为重算分值
                                ScoreFunctionBuilders.fieldValueFactorFunction("advertiseAmount")
                        )
                }
                // 加权模式，使用乘法加权，算出最终结果
        ).boostMode(CombineFunction.MULTIPLY);
        request.source().query(functionScoreQueryBuilder);
    
    // 省略
}
```

重启系统，先查询这个用例，发现“上海颖奕皇冠假日酒店”是排序最后的：

![image](https://user-images.githubusercontent.com/48977889/168414857-1e6697a4-58ab-4ce4-9967-da11de42f9e9.png)

现在给它充1000块

```
POST hotel/_update/200215226
{
  "doc": {
    "advertiseAmount":1000
  }
}
```

在查询，发现排到第1了：

![image](https://user-images.githubusercontent.com/48977889/168415045-c713fe28-e930-4611-9ee1-46409b9812d9.png)